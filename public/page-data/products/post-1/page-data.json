{"componentChunkName":"component---src-pages-products-markdown-remark-frontmatter-slug-jsx","path":"/products/post-1/","result":{"data":{"markdownRemark":{"fields":{"slug":"/products/post-1/"},"html":"<h1>Table of Contents</h1>\n<ol>\n<li><a href=\"#orga30e933\">Intent</a></li>\n<li><a href=\"#org4ab8af0\">Examples</a>\n<ol>\n<li><a href=\"#org5ab5ce9\">Chess with alternate rules</a></li>\n<li><a href=\"#org7c9d799\">Notifier</a></li>\n</ol>\n</li>\n</ol>\n<p><a id=\"orga30e933\"></a></p>\n<h1>Intent</h1>\n<p>A decorator design pattern allows for optional addition of new behaviors to an object.</p>\n<p>Creating classes for a specific combination of behaviors that utilize the same data can become unwieldly, such as in the case of an object with multiple sets of rules stemming from a common point.</p>\n<p><a id=\"org4ab8af0\"></a></p>\n<h1>Examples</h1>\n<p><a id=\"org5ab5ce9\"></a></p>\n<h2>Chess with alternate rules</h2>\n<p>Iâ€™m currently implementing a chess game with alternate rules <em>based</em> off of the standard ruleset of chess, in which players can decide multiple modes. In this case, some game modes will extend and add new behaviors to existing classes.</p>\n<p>Pieces can still move, however they may have additional rules or modifiers that alter their movesets. A decorator/wrapper in place of the class itself will allow for attachment of new behaviors without repeating behavior for every combination, instead the behaviors stack.</p>\n<p><a id=\"org7c9d799\"></a></p>\n<h2>Notifier</h2>\n<p>A general notification class that sends messages. Attaching behaviors to the notifier class depending on user preferences (slack, discord, sms, email). With decorators, the notification message will travel across sub-classes of behavior.</p>","frontmatter":{"date":"July 19, 2023","title":"Decorators"}}},"pageContext":{"slug":"/products/post-1/"}},"staticQueryHashes":["1828880655","63159454"],"slicesMap":{}}